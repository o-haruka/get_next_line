## コンパイル・実行
cc -Wall -Wextra -Werror -D BUFFER_SIZE=42 *.c -o get_next_line
./get_next_line

## ft_getc
### 概要
この関数は、ファイルディスクリプタから1文字ずつ読み取るための関数で、内部でバッファリングを行って効率的な読み取りを実現しています。

### 仕組み

### Static変数の役割
```c
static char	buf[BUFFER_SIZE];  // 読み取りバッファ
static char	*p;                // バッファ内の現在位置
static int	n = 0;             // バッファ内の残りバイト数
```

これらのstatic変数により、関数呼び出し間で状態が保持されます。

### 動作フロー

1. **バッファが空の場合** (`n == 0`)
   ```c
   n = read(fd, buf, BUFFER_SIZE);
   ```
   - `BUFFER_SIZE`分のデータを一度に読み取り
   - `read`が失敗した場合（`n < 0`）は`-2`を返してエラーを示す
   - ファイル終端の場合（`n == 0`）は`EOF`を返す
   - 成功時はポインタ`p`をバッファの先頭に設定

2. **バッファにデータがある場合** (`n > 0`)
   ```c
   n--;
   return ((unsigned char)*p++);
   ```
   - 残りバイト数をデクリメント
   - 現在位置の文字を返し、ポインタを次に進める
   - `unsigned char`にキャストして負の値を避ける

### 利点
- **効率性**: 1文字ずつ`read`を呼ぶより、まとめて読み取る方が高速
- **シンプルな使用**: 呼び出し側は1文字ずつ取得できる
- **エラー区別**: 正常終端（`EOF`）とエラー（`-2`）を区別

### 注意点
- static変数を使用しているため、複数のファイルディスクリプタを同時に扱えない
- ファイルディスクリプタが変わっても状態がリセットされない
- スレッドセーフではない

この実装は、シンプルな単一ファイル読み取りには効率的ですが、複数ファイルを扱う場合は別のアプローチが必要。

## readが失敗したとき-2を返すのはなぜ？
エラーの区別をするために正常終端（EOF）とエラー（-2）に分けることはわかったが、なぜエラーは-2なのか？
read()は通常エラーのとき-1が返るはず。

### 理由は `EOF` の値との衝突を避けるため

標準Cライブラリでは、`EOF`マクロは通常`-1`として定義されている。：

```c
#define EOF (-1)
```

もし`ft_getc()`で`read()`のエラー値`-1`をそのまま返すと：

```c
// もしこうだった場合
if (n < 0)
    return (-1);  // これはEOFと同じ値！
```

呼び出し側で以下のような問題が発生します：

```c
c = ft_getc(fd);
if (c == EOF)  // -1
{
    // これが「正常なファイル終端」なのか
    // 「read()のエラー」なのか区別できない！
}
```

#### 解決策として `-2` を使用

```c
if (n < 0)
{
    n = 0;
    return (-2);  // EOFとは異なる値でエラーを示す
}
```

これにより、`get_next_line()`で明確に区別できます：

```c
c = ft_getc(fd);
if (c == -2)           // read()エラー
    return (ft_free(ret.str));
if (c == EOF)          // 正常なファイル終端
    break;
```

#### まとめ

- `read()`は確かにエラー時に`-1`を返す
- しかし`EOF`も`-1`なので、そのまま返すと区別できない（正常終端なのかエラーなのかわからない）
- そのため独自のエラー値`-2`を使って区別している

これは、標準ライブラリの`getc()`と同様の考え方で、エラーと正常終端を区別するための設計です。
