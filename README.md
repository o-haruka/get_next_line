## コンパイル・実行
cc -Wall -Wextra -Werror -D BUFFER_SIZE=42 *.c -o get_next_line
./get_next_line

## 疑問とか
### readが失敗したとき-2を返すのはなぜ？
エラーの区別をするために正常終端（EOF）とエラー（-2）に分けることはわかったが、なぜエラーは-2なのか？
read()は通常エラーのとき-1が返るはず。

→答え

## 理由は `EOF` の値との衝突を避けるため

標準Cライブラリでは、`EOF`マクロは通常`-1`として定義されている。：

```c
#define EOF (-1)
```

もし`ft_getc()`で`read()`のエラー値`-1`をそのまま返すと：

```c
// もしこうだった場合
if (n < 0)
    return (-1);  // これはEOFと同じ値！
```

呼び出し側で以下のような問題が発生します：

```c
c = ft_getc(fd);
if (c == EOF)  // -1
{
    // これが「正常なファイル終端」なのか
    // 「read()のエラー」なのか区別できない！
}
```

## 解決策として `-2` を使用

```c
if (n < 0)
{
    n = 0;
    return (-2);  // EOFとは異なる値でエラーを示す
}
```

これにより、`get_next_line()`で明確に区別できます：

```c
c = ft_getc(fd);
if (c == -2)           // read()エラー
    return (ft_free(ret.str));
if (c == EOF)          // 正常なファイル終端
    break;
```

## まとめ

- `read()`は確かにエラー時に`-1`を返す
- しかし`EOF`も`-1`なので、そのまま返すと区別できない（正常終端なのかエラーなのかわからない）
- そのため独自のエラー値`-2`を使って区別している

これは、標準ライブラリの`getc()`と同様の考え方で、エラーと正常終端を区別するための設計です。
